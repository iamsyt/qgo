/*
* board.cpp
*/
#include "board.h"
#include "../defines.h"

#include <vector>

#include <QtGui>
//#include <QtGlobal>

Board::Board(QWidget *parent, QGraphicsScene *c, int size)
: QGraphicsView(c,parent)
{


	viewport()->setMouseTracking(TRUE);
	lockResize =  false ;
	board_size = size;//DEFAULT_BOARD_SIZE;
/*	showCoords = setting->readBoolEntry("BOARD_COORDS");
	showSGFCoords = setting->readBoolEntry("SGF_BOARD_COORDS");
	antiClicko = setting->readBoolEntry("ANTICLICKO");
	
	// Create a BoardHandler instance.
	boardHandler = new BoardHandler(this);
	CHECK_PTR(boardHandler);
	
	// Create an ImageHandler instance.
	imageHandler = new ImageHandler();
	CHECK_PTR(imageHandler);
*/	
	// Init the canvas
	canvas = new QGraphicsScene(0,0,BOARD_X, BOARD_Y,this);
//	CHECK_PTR(canvas);
//	canvas->setDoubleBuffering(TRUE);
////	canvas->resize(BOARD_X, BOARD_Y);
	setScene(canvas);
	//gatter = new Gatter(canvas, board_size);
	

/*		
	// Init data storage for marks and ghosts
	marks = new QPtrList<Mark>;
	marks->setAutoDelete(TRUE);
	lastMoveMark = NULL;
	
	ghosts = new QList<Stone>;
	ghosts->setAutoDelete(TRUE);
*/	
	// Init the gatter size and the imagehandler pixmaps
	calculateSize();

/*	imageHandler->init(square_size);
	
	// Initialize some class variables
	nodeResultsDlg = NULL;
	fastLoad = false;
	isModified = false;
	mouseState = NoButton;
	for (int i=0; i<400; i++)
	{
		if (i < 52)
			letterPool[i] = false;
		numberPool[i] = false;
	}
	//coordsTip = new Tip(this);
#ifdef Q_WS_WIN
	resizeDelayFlag = false;
#endif
	curX = curY = -1;
	showCursor = setting->readBoolEntry("CURSOR");
	
	isLocalGame = true;
	
	// Init the ghost cursor stone
	curStone = new Stone(imageHandler->getGhostPixmaps(), canvas, stoneBlack, 0, 0);
	curStone->setZ(4);
	curStone->hide();                       

	lockResize = false;
	navIntersectionStatus = false;
  
	updateCaption();
*/


}

Board::~Board()
{

}


/*
* Calculates the size of the goban
*/
void Board::calculateSize()
{
	// Calculate the size values
	const int 	margin = 1,              // distance from table edge to wooden board edge
		w = (int)canvas->width() - margin * 2,  
		h = (int)canvas->height() - margin * 2;

	int table_size = (w < h ? w : h );

	offset = table_size * 2/100 ;  // distance from edge of wooden board to playing area (grids + space for stones on 1st & last line)


	QGraphicsSimpleTextItem *coordV = new QGraphicsSimpleTextItem(QString::number(board_size),0, canvas);
	QGraphicsSimpleTextItem *coordH = new QGraphicsSimpleTextItem("A",0, canvas);
	int coord_width = (int)coordV->boundingRect().width();
	int coord_height = (int)coordH->boundingRect().height();

	// space for coodinates if shown
	int coord_offset =  (coord_width < coord_height ? coord_height : coord_width);

	if (showCoords)
		offset = coord_offset + 2 ;

	//we need 1 more virtual 'square' for the stones on 1st and last line getting off the grid
	square_size = (table_size - 2*offset) / (board_size);  

	// Should not happen, but safe is safe.
	if (square_size == 0)
		  square_size = 1;

	board_pixel_size = square_size * (board_size-1);    // grid size
	offset =  (table_size - board_pixel_size)/2;   

	// Center the board in canvas

	offsetX = margin + (w - board_pixel_size) / 2;
	offsetY = margin + (h - board_pixel_size) / 2;

	//deletes the samples
	delete coordV;
	delete coordH;

}


/*
* actually draws the gatter lines
*/
void Board::drawGatter()
{
	//gatter->resize(offsetX,offsetY,square_size);	

}

/*
* draws the table under the goban, and the goban wood texture
*/
void Board::drawBackground()
{
	int 	w = (int)canvas->width(),
		h = (int)canvas->height();
	
	// Create pixmap of appropriate size
	QPixmap all(w, h);

	// Paint table and board on the pixmap
	QPainter painter;

	painter.begin(&all);
	painter.setPen(Qt::NoPen);

	painter.drawTiledPixmap (0, 0, w, h,QPixmap::QPixmap("/home/eb/Packages/qgo2/src/board/ressources/pics/table.png"));
	//(ImageHandler::getTablePixmap(  setting->readEntry("SKIN_TABLE"))));

	painter.drawTiledPixmap (
		offsetX - offset,
		offsetY - offset,
		board_pixel_size + offset*2,
		board_pixel_size + offset*2,
		//(ImageHandler::getBoardPixmap(setting->readEntry("SKIN"))));
		QPixmap::QPixmap("/home/eb/Packages/qgo2/src/board/ressources/pics/wood.png"));
	painter.end();

	QImage image = all.toImage();
	int lighter=20;
	int darker=60;
	int width = 3; 

	int x,y;
	for(x=0;x<width;x++)
		for (y= offsetY - offset +x ; y<offsetY + board_pixel_size + offset-x ;y++)
		{
			image.setPixel(
				offsetX - offset+x , 
				y, 
				QColor(image.pixel(offsetX - offset+x,y)).dark(int(100 + darker*(width-x)*(width-x)/width/width)).rgb());

			image.setPixel(
				offsetX + board_pixel_size + offset-x -1, 
				y,
				QColor(image.pixel(offsetX + board_pixel_size + offset-x-1,y)).light(100+ int(lighter*(width-x)*(width-x)/width/width)).rgb());
		}

	for(y=0;y<width;y++)
		for (x= offsetX - offset +y ; x<offsetX + board_pixel_size + offset-y ;x++)
		{
			image.setPixel(
				x,
				offsetY - offset+y , 
				QColor(image.pixel(x,offsetY - offset+y)).light(int(100 + lighter*(width-y)*(width-y)/width/width)).rgb());

			image.setPixel(
				x,
				offsetY + board_pixel_size + offset-y -1, 
				QColor(image.pixel(x,offsetY + board_pixel_size + offset-y-1)).dark(100+ int(darker*(width-y)*(width-y)/width/width)).rgb());
		}


	width = 10;
	darker=50;

	for(x=0;(x<=width)&&(offsetX - offset-x >0) ;x++)
		for (y= offsetY - offset+x ; (y<offsetY + board_pixel_size + offset+x)&&(y<h) ;y++)
		{
			image.setPixel(
				offsetX - offset-1-x  , 
				y, 
				QColor(image.pixel(offsetX - offset-1-x,y)).dark(int(100 + darker*(width-x)/width)).rgb());
		}

	for(y=0;(y<=width)&&(offsetY + board_pixel_size + offset+y+1<h);y++)
		for (x= (offsetX - offset - y > 0 ? offsetX - offset - y:0) ; x<offsetX + board_pixel_size + offset-y ;x++)
		{
			image.setPixel(
				x,
				offsetY + board_pixel_size + offset+y +1, 
				QColor(image.pixel(x,offsetY + board_pixel_size + offset+y+1)).dark(100+ int(darker*(width-y)/width)).rgb());
		}

	//redraws the image on a brush to set the background
	canvas->setBackgroundBrush ( QBrush::QBrush(image));

}


/*
* the viewport is resized
*/
void Board::resizeEvent(QResizeEvent*)
{
#ifdef _WS_WIN_x
    if (!resizeDelayFlag)
    {
		resizeDelayFlag = true;
		// not necessary?
		QTimer::singleShot(50, this, SLOT(changeSize()));
    }
#else
	if (!lockResize)
		changeSize();
#endif
}



/*
* called by the resize event
*/
void Board::changeSize()
{
#ifdef Q_WS_WIN
	resizeDelayFlag = false;
#endif

	QSize s = QSize::QSize(width()-5, height()-5);
	resizeBoard(s.width(), s.height());
}


/*
* does the resizing work
*/
void Board::resizeBoard(int w, int h)
{
	if (w < 30 || h < 30)
		return;

    // Resize canvas
	canvas->setSceneRect(0,0,w,h);

    // Recalculate the size values
	calculateSize();

    // Rescale the pixmaps in the ImageHandler


    // Delete gatter lines and update stones positions
	QList<QGraphicsItem *> list = canvas->items();
	QGraphicsItem *item;
	QList<QGraphicsItem *>::iterator it;

	for(it = list.begin(); it != list.end(); ++it)
	{
		item = *it;
		if (item->type() == 6 || item->type() == 3)// || item->rtti() == 7)
		{
			item->hide();
			delete item;
		}
		else if (item->type() == RTTI_STONE)
		{
/*			Stone *s = (Stone*)item;
			s->setX(offsetX + square_size * (s->posX() - 1));
			s->setY(offsetY + square_size * (s->posY() - 1));
*/		}
		else if (item->type() >= RTTI_MARK_SQUARE &&
			item->type() <= RTTI_MARK_TERR)
		{
/*			Mark *m;
			switch(item->rtti())
			{
			case RTTI_MARK_SQUARE: m = (MarkSquare*)item; break;
			case RTTI_MARK_CIRCLE: m = (MarkCircle*)item; m->setSmall(setting->readBoolEntry("SMALL_MARKS")); break;
			case RTTI_MARK_TRIANGLE: m = (MarkTriangle*)item; break;
			case RTTI_MARK_CROSS: m = (MarkCross*)item; break;
			case RTTI_MARK_TEXT: m = (MarkText*)item; break;
			case RTTI_MARK_NUMBER: m = (MarkNumber*)item; break;
			case RTTI_MARK_TERR: m = (MarkTerr*)item; break;
			default: continue;
			}
			m->setSize((double)square_size, (double)square_size);
			m->setX((double)offsetX + (double)square_size * ((double)(m->posX()) - 1.0) -
				(double)m->getSizeX()/2.0);
			m->setY((double)offsetY + (double)square_size * ((double)(m->posY()) - 1.0) -
				(double)m->getSizeY()/2.0);
*/		 }
	}

//	boardHandler->gotoMove(m_save);

	// Redraw the board
	drawBackground();
//	drawGatter();
//	if (showCoords)
//		drawCoordinates();

  // Redraw the mark on the last played stone                             
//  updateLastMove(m_save->getColor(), m_save->getX(), m_save->getY()); 
  
//	canvas->update();
}

 /*
  * Initialises the gatter intersections and hoshis points
  */
Gatter::Gatter(QGraphicsScene *Canvas, int size)
{
	int i,j;

	board_size = size;
	canvas=Canvas;	

//	VGatter2[board_size*i + j] = new QGraphicsLineItem(0,canvas) ;
//VGatter2.reserve(board_size*board_size);
	
	VGatter.reserve(board_size);
	HGatter.reserve(board_size);
	for (i=0; i<board_size; i++)
	{	
		std::vector<QGraphicsLineItem *> row,col;
		row.reserve(board_size);
		col.reserve(board_size);
		VGatter.push_back(row);
		HGatter.push_back(col);
		
		for (j=0; j<board_size; j++)
		{
//			VGatter2.push_back(QGraphicsLineItem::QGraphicsLineItem(0,canvas)) ;
			
			VGatter[i].push_back(new QGraphicsLineItem(0,canvas));
			HGatter[i].push_back(new QGraphicsLineItem(0,canvas));
			Q_CHECK_PTR(VGatter[i][j]);
			Q_CHECK_PTR(HGatter[i][j]);
		}
	}
	
	int edge_dist = (board_size > 12 ? 4 : 3);
	int low = edge_dist;
	int middle = (board_size + 1) / 2;
	int high = board_size + 1 - edge_dist;
	if (board_size % 2 && board_size > 9)
/*	{
		hoshisList.insert(middle*board_size + low , new QGraphicsEllipseItem(0,canvas));
		hoshisList.insert(middle*board_size + middle , new QGraphicsEllipseItem(0,canvas));
		hoshisList.insert(middle*board_size + high , new QGraphicsEllipseItem(0,canvas));
		hoshisList.insert(low*board_size + middle , new QGraphicsEllipseItem(0,canvas));
		hoshisList.insert(high*board_size + middle , new QGraphicsEllipseItem(0,canvas));
	}
	hoshisList.insert(low*board_size + low ,new QGraphicsEllipseItem(0,canvas));
	hoshisList.insert(high*board_size + low , new QGraphicsEllipseItem(0,canvas));
	hoshisList.insert(high*board_size + high , new QGraphicsEllipseItem(0,canvas));
	hoshisList.insert(low*board_size + high ,new QGraphicsEllipseItem(0,canvas));
*/
//	QMapIterator<int,QGraphicsEllipseItem> it( hoshisList );
//	for ( ; it.hasNext(); )
//        	it.next()->setBrush(Qt::black);

//	QGraphicsLineItem *hop = HGatter[0][0];
//	HGatter[0][0]->setLine(0,0,0,0);
	showAll();
}

 /*
  * Destroys the gatter
  */
Gatter::~Gatter()
{
	int i,j; 


	for (i=0; i<board_size; i++)
 	{
		for (j=0; j<board_size; j++)
 		{
 			delete VGatter[i][j];
			delete HGatter[i][j];
		} 
	VGatter[i].clear();
	HGatter[i].clear();	
	}

	VGatter.clear();	
	HGatter.clear();

	//QMapIterator<int,QGraphicsEllipseItem> it( hoshisList );
	//for ( ; it.current(); ++it )
        //	delete it.current(); 
	hoshisList.clear();

}



 /*
  * Calculates the gatter intersections and hoshis position
  */
void Gatter::resize(int offsetX, int offsetY, int square_size)
{
	int i,j;
	QGraphicsEllipseItem *e;
	QMapIterator<int,QGraphicsEllipseItem*> it( hoshisList );
	
	int size = square_size / 5;
	// Round size top be even
	if (size % 2 > 0)
		size--;
	if (size < 6)
		size = 6;

//	QGraphicsLineItem *hop = (QGraphicsLineItem *)HGatter[0][0];
//	hop->setLine(0,0,0,0);

	for (i=0; i<board_size; i++)
		for (j=0; j<board_size; j++)
		{
			Q_CHECK_PTR(VGatter[i][j]);
			Q_CHECK_PTR(HGatter[i][j]);
/*			VGatter2[board_size*i + j].setLine(offsetX + square_size *  i, 
						int(offsetY + square_size * ( j - 0.5*(j!=0))),
						offsetX + square_size *  i, 
						int(offsetY + square_size * ( j + 0.5 * (j+1 != board_size)))); 

/*			HGatter[i][j]->setLine(int(offsetX + square_size * ( i - 0.5*(i!=0))), 
						offsetY + square_size * j,
						int(offsetX + square_size * ( i + 0.5 * (i+1 != board_size))), 
						offsetY + square_size * j );
			
			VGatter[i][j]->setLine(offsetX + square_size *  i, 
						int(offsetY + square_size * ( j - 0.5*(j!=0))),
						offsetX + square_size *  i, 
						int(offsetY + square_size * ( j + 0.5 * (j+1 != board_size)))); 
			
			
/*			it=hoshisList.find(board_size*(i+1)+j+1);
			e=it.value();
			if (e)
			{
				e->setRect(offsetX + square_size * i,
					offsetY + square_size * j,
					size, 
					size);
    				//e->setX(offsetX + square_size * i);
    				//e->setY(offsetY + square_size * j);
			}
*/		}

}

/*
* Resets all interctions and hoshis to be shown
*/
void Gatter::showAll()
{
	int i,j;
	QGraphicsEllipseItem *e;

	for (i=0; i<board_size; i++)
		for (j=0; j<board_size; j++)
		{
//			VGatter[i][j]->show();
			HGatter[i][j]->show();
	
//			VGatter2[board_size*i + j]->show();


		}
/*
	QMapIterator<int,QGraphicsEllipseItem*> it( hoshisList );
	for ( ; it.current(); ++it )
        	it.current()->show();
*/
}

 /*
  * Hides an intersection (when placing a letter mark)
  */
void Gatter::hide(int i, int j)
{
	QGraphicsEllipseItem *e;
	
	if (( i<1) || (i > board_size) || ( j<1) || (j > board_size))
		return;

//	VGatter[i-1][j-1]->hide();
	HGatter[i-1][j-1]->hide();
/*
	e=hoshisList.find(board_size*i+j);
	if (e)
		e->hide();
*/
}

 /*
  * shows an intersection (when removing a letter mark)
  */
void Gatter::show(int i, int j)
{
	QGraphicsEllipseItem *e;

	if (( i<1) || (i > board_size) || ( j<1) || (j > board_size))
		return;

//	VGatter[i-1][j-1]->show();
	HGatter[i-1][j-1]->show();
/*
	e=hoshisList.find(board_size*i+j);
	if (e)
		e->show();
*/
}
